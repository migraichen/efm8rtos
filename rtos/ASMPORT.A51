; D:\efm8rtos\rtos\asmport.SRC generated from: D:\efm8rtos\rtos\asmport.c
; COMPILER INVOKED BY:
;        c:\SiliconLabs\SimplicityStudio\v4\developer\toolchains\keil_8051\9.60\BIN\C51.exe D:\efm8rtos\rtos\asmport.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SPEED) INTVECTOR(0X0000) INTPROMOTE INCDIR(D:/efm8rtos/rtos/include;D:/efm8rtos/inc;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.7//Device/shared/si8051Base;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.7//Device/EFM8BB3/inc) REGFILE(efm8rtos.ORC) PRINT(.\rtos\asmport.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\rtos\asmport.OBJ)

$NOMOD51

NAME	ASMPORT

SPI0CKR	DATA	0A2H
P0	DATA	080H
SCON1_PERR	BIT	0C8H.6
PSW_OV	BIT	0D0H.2
XOSC0CN	DATA	086H
P1	DATA	090H
SPI0CN0_TXNF	BIT	0F8H.1
WDTCN	DATA	097H
P2	DATA	0A0H
P3	DATA	0B0H
SMB0CN0_MASTER	BIT	0C0H.7
PCA0	DATA	0F9H
EIE1	DATA	0E6H
SMB0CN0_ACK	BIT	0C0H.1
CLIF0_C0RIF	BIT	0E8H.1
EIE2	DATA	0F3H
CLIF0_C1RIF	BIT	0E8H.3
CLIF0_C2RIF	BIT	0E8H.5
PSCTL	DATA	08FH
CLIF0_C3RIF	BIT	0E8H.7
IT01CF	DATA	0E4H
SMB0CN0_TXMODE	BIT	0C0H.6
DERIVID	DATA	0ADH
SFRPAGE	DATA	0A7H
P0MDOUT	DATA	0A4H
P1MDOUT	DATA	0A5H
ADC0CN0_ADINT	BIT	0E8H.5
TMR2RLH	DATA	0CBH
P2MDOUT	DATA	0A6H
IE	DATA	0A8H
TMR3RLH	DATA	093H
P3MDOUT	DATA	09CH
TMR4RLH	DATA	0A3H
EIP1	DATA	0BBH
TMR5RLH	DATA	0D3H
EIP2	DATA	0EDH
SCON0_RB8	BIT	098H.2
TMR2RLL	DATA	0CAH
PCA0CPH0	DATA	0FCH
TMR3RLL	DATA	092H
PCA0CPH1	DATA	0EAH
SCON0_TB8	BIT	098H.3
B_B0	BIT	0F0H.0
DP	DATA	082H
TMR4RLL	DATA	0A2H
PCA0CPH2	DATA	0ECH
B_B1	BIT	0F0H.1
ADC0GT	DATA	0C3H
TMR5RLL	DATA	0D2H
PCA0CPH3	DATA	0F5H
I2C0SLAD	DATA	0BDH
UART1FCN1_RFRQ	BIT	0D8H.3
B_B2	BIT	0F0H.2
SFRPGCN	DATA	0BCH
PCA0CPL0	DATA	0FBH
PCA0CPH4	DATA	085H
B_B3	BIT	0F0H.3
PCA0MD	DATA	0D9H
PCA0CPM0	DATA	0DAH
PCA0CPL1	DATA	0E9H
PCA0CPH5	DATA	0DEH
UART1FCN1_TFRQ	BIT	0D8H.7
B_B4	BIT	0F0H.4
PCA0CPM1	DATA	0DBH
PCA0CPL2	DATA	0EBH
ADC0ASCF	DATA	0A1H
ADC0ASAH	DATA	0B6H
B_B5	BIT	0F0H.5
ADC0CN0_IPOEN	BIT	0E8H.6
ADC0CN0_TEMPE	BIT	0E8H.0
PCA0CPM2	DATA	0DCH
PCA0CPL3	DATA	0F4H
IP	DATA	0B8H
B_B6	BIT	0F0H.6
ADC0LT	DATA	0C5H
PCA0CPM3	DATA	0AEH
PCA0CPL4	DATA	084H
UART1FCN1_TXNF	BIT	0D8H.6
SCON0_MCE	BIT	098H.5
B_B7	BIT	0F0H.7
PCA0CPM4	DATA	0AFH
PCA0CPL5	DATA	0DDH
SMB0FCN0	DATA	0C3H
PCA0CPM5	DATA	0CCH
ADC0ASAL	DATA	0B5H
XBR0	DATA	0E1H
SMB0FCN1	DATA	0C4H
SMB0CF	DATA	0C1H
XBR1	DATA	0E2H
PFE0CN	DATA	0C1H
EMI0CN	DATA	0E7H
SMB0CN0_STA	BIT	0C0H.5
XBR2	DATA	0E3H
CLU0CF	DATA	0B1H
ADC0MX	DATA	0BBH
ACC_ACC0	BIT	0E0H.0
REF0CN	DATA	0D1H
CLU1CF	DATA	0B3H
CKCON0	DATA	08EH
ACC_ACC1	BIT	0E0H.1
REG0CN	DATA	0C9H
CRC0IN	DATA	0CAH
CLU2CF	DATA	0B6H
CKCON1	DATA	0A6H
TMR2CN0_TR2	BIT	0C8H.2
ACC_ACC2	BIT	0E0H.2
CLU3CF	DATA	0BFH
ACC_ACC3	BIT	0E0H.3
SP	DATA	081H
CMP0MD	DATA	09DH
ACC_ACC4	BIT	0E0H.4
LFO0CN	DATA	0B1H
CMP1MD	DATA	0ABH
PCA0CN0_CCF0	BIT	0D8H.0
ACC_ACC5	BIT	0E0H.5
TMR4CN0_TR4	BIT	098H.2
PCA0CN0_CCF1	BIT	0D8H.1
ACC_ACC6	BIT	0E0H.6
TMR2	DATA	0CEH
SPI0FCN0	DATA	09AH
ADC0ASCT	DATA	0C7H
PCA0CN0_CCF2	BIT	0D8H.2
ACC_ACC7	BIT	0E0H.7
TMR3	DATA	094H
SPI0FCN1	DATA	09BH
TMR5CN0_TR5	BIT	0C0H.2
PCA0CN0_CCF3	BIT	0D8H.3
TMR4	DATA	0A4H
SBCON1	DATA	094H
PCA0CN0_CCF4	BIT	0D8H.4
TMR5	DATA	0D4H
SMB0CN0_ACKRQ	BIT	0C0H.3
PCA0CN0_CCF5	BIT	0D8H.5
VDM0CN	DATA	0FFH
P0MDIN	DATA	0F1H
CLU0FN	DATA	0AFH
SCON0_REN	BIT	098H.4
SMB0TC	DATA	0ACH
P1MDIN	DATA	0F2H
CLU1FN	DATA	0B2H
SCON1_REN	BIT	0C8H.4
P2MDIN	DATA	0F3H
CLU2FN	DATA	0B5H
SMB0CN0_STO	BIT	0C0H.4
P3MDIN	DATA	0F4H
I2C0STAT	DATA	0B9H
I2C0DOUT	DATA	0BBH
CLU3FN	DATA	0BEH
SBRLH1	DATA	096H
P0MASK	DATA	0FEH
UART1FCN1_TXHOLD	BIT	0D8H.5
P1MASK	DATA	0EEH
P2MASK	DATA	0FCH
PSW_RS0	BIT	0D0H.3
PCA0CN0_CF	BIT	0D8H.7
PCA0CENT	DATA	09EH
I2C0CN0	DATA	0BAH
CRC0ST	DATA	0D2H
SPI0CN0_RXOVRN	BIT	0F8H.4
PSW_RS1	BIT	0D0H.4
SBRLL1	DATA	095H
SCON1_RBX	BIT	0C8H.2
DAC0CF0	DATA	091H
ADC0CF0	DATA	0BCH
TMR2CN0_T2XCLK0	BIT	0C8H.0
DAC1CF0	DATA	093H
DAC0CF1	DATA	092H
ADC0CF1	DATA	0B9H
TMR2CN0_T2XCLK1	BIT	0C8H.1
SCON1_TBX	BIT	0C8H.3
ADC0CN0_ADEN	BIT	0E8H.7
TMOD	DATA	089H
TCON	DATA	088H
DAC2CF0	DATA	095H
DAC1CF1	DATA	094H
ADC0CF2	DATA	0DFH
DAC3CF0	DATA	09AH
DAC2CF1	DATA	096H
CRC0FLIP	DATA	0CFH
PSW_PARITY	BIT	0D0H.0
IE_ES0	BIT	0A8H.4
DAC3CF1	DATA	09CH
CMP0MX	DATA	09FH
TMR4CN0_T4XCLK0	BIT	098H.0
IE_ET0	BIT	0A8H.1
CMP1MX	DATA	0AAH
TMR4CN0_T4XCLK1	BIT	098H.1
IE_ET1	BIT	0A8H.3
P0SKIP	DATA	0D4H
CLOUT0	DATA	0D1H
UART1FCN1_RIE	BIT	0D8H.0
TMR5CN0_T5XCLK0	BIT	0C0H.0
IE_ET2	BIT	0A8H.5
DACGCF0_D1SRC0	BIT	088H.0
P1SKIP	DATA	0D5H
TMR5CN0_T5XCLK1	BIT	0C0H.1
DACGCF0_D1SRC1	BIT	088H.1
P2SKIP	DATA	0CCH
CLU0MX	DATA	084H
ADC0CN0	DATA	0E8H
UART1FCN1_TIE	BIT	0D8H.4
IE_EX0	BIT	0A8H.0
DACGCF0_D3SRC0	BIT	088H.4
CLU1MX	DATA	085H
ADC0CN1	DATA	0B2H
PCA0CN0_CR	BIT	0D8H.6
IE_EX1	BIT	0A8H.2
DACGCF0_D3SRC1	BIT	088H.5
CLU2MX	DATA	091H
ADC0CN2	DATA	0B3H
SCON1_OVR	BIT	0C8H.7
PSTAT0	DATA	0AAH
CLU3MX	DATA	0AEH
SCON0_SMODE	BIT	098H.7
DEVICEID	DATA	0B5H
CLKSEL	DATA	0A9H
SPI0CN0_SPIEN	BIT	0F8H.0
DAC0H	DATA	085H
B	DATA	0F0H
ADC0H	DATA	0BEH
I2C0ADM	DATA	0FFH
DAC1H	DATA	08AH
DACGCF0_D1AMEN	BIT	088H.2
DAC2H	DATA	08CH
DAC3H	DATA	08EH
DACGCF0_D3AMEN	BIT	088H.6
TMR2RL	DATA	0CAH
DAC0L	DATA	084H
ADC0L	DATA	0BDH
TMR3RL	DATA	092H
DAC1L	DATA	089H
TMR4RL	DATA	0A2H
PCA0CN0	DATA	0D8H
DAC2L	DATA	08BH
ACC	DATA	0E0H
TMR5RL	DATA	0D2H
UART0PCF	DATA	0D9H
DAC3L	DATA	08DH
PCA0CP0	DATA	0FBH
UART1PCF	DATA	0DAH
PCA0CP1	DATA	0E9H
DACGCF0	DATA	088H
PCA0CP2	DATA	0EBH
I2C0DIN	DATA	0BCH
DACGCF1	DATA	098H
CRC0CN0	DATA	0CEH
PCA0CP3	DATA	0F4H
TH0	DATA	08CH
DACGCF2	DATA	0A2H
CRC0CN1	DATA	086H
IP_PS0	BIT	0B8H.4
PCA0CP4	DATA	084H
UART1FCT	DATA	0FAH
TH1	DATA	08DH
PCA0H	DATA	0FAH
I2C0FCT	DATA	0F5H
IP_PT0	BIT	0B8H.1
PCA0CP5	DATA	0DDH
CLIE0	DATA	0C7H
IP_PT1	BIT	0B8H.3
DACGCF0_D01REFSL	BIT	088H.3
ADC0ASA	DATA	0B5H
CLIF0	DATA	0E8H
SMB0CN0_ARBLOST	BIT	0C0H.2
IP_PT2	BIT	0B8H.5
TL0	DATA	08AH
PSW_F0	BIT	0D0H.5
IE_ESPI0	BIT	0A8H.6
TL1	DATA	08BH
PCA0L	DATA	0F9H
SMB0CN0_SI	BIT	0C0H.0
PSW_F1	BIT	0D0H.1
P0_B0	BIT	080H.0
IP_PX0	BIT	0B8H.0
P1_B0	BIT	090H.0
P0_B1	BIT	080H.1
IP_PX1	BIT	0B8H.2
DACGCF0_D23REFSL	BIT	088H.7
UART1LIN	DATA	09EH
CMP0CN0	DATA	09BH
CLEN0	DATA	0C6H
TCON_IE0	BIT	088H.1
P2_B0	BIT	0A0H.0
P1_B1	BIT	090H.1
P0_B2	BIT	080H.2
CMP1CN0	DATA	0BFH
CMP0CN1	DATA	099H
TCON_IE1	BIT	088H.3
P3_B0	BIT	0B0H.0
P2_B1	BIT	0A0H.1
P1_B2	BIT	090H.2
P0_B3	BIT	080H.3
SMB0CN0	DATA	0C0H
CMP1CN1	DATA	0ACH
P3_B1	BIT	0B0H.1
P2_B2	BIT	0A0H.2
P1_B3	BIT	090H.3
P0_B4	BIT	080H.4
P3_B2	BIT	0B0H.2
P2_B3	BIT	0A0H.3
P1_B4	BIT	090H.4
P0_B5	BIT	080H.5
DACGCF1_D0UDIS	BIT	098H.0
UART1FCN1_RXTO0	BIT	0D8H.1
P3_B3	BIT	0B0H.3
P2_B4	BIT	0A0H.4
P1_B5	BIT	090H.5
P0_B6	BIT	080H.6
DACGCF1_D1UDIS	BIT	098H.1
EIP1H	DATA	0EEH
UART1FCN1_RXTO1	BIT	0D8H.2
P3_B4	BIT	0B0H.4
P2_B5	BIT	0A0H.5
P1_B6	BIT	090H.6
P0_B7	BIT	080H.7
DACGCF1_D2UDIS	BIT	098H.2
SMB0RXLN	DATA	0C5H
EIP2H	DATA	0F6H
P2_B6	BIT	0A0H.6
P1_B7	BIT	090H.7
DACGCF1_D3UDIS	BIT	098H.3
P3_B7	BIT	0B0H.7
DPH	DATA	083H
ADC0GTH	DATA	0C4H
TMR2CN0_TF2H	BIT	0C8H.7
TMR2CN0_T2SPLIT	BIT	0C8H.3
PSW_AC	BIT	0D0H.6
SPI0CN0	DATA	0F8H
HFO0CAL	DATA	0C7H
TCON_TF0	BIT	088H.5
SCON0_RI	BIT	098H.0
HFO1CAL	DATA	0D6H
DPL	DATA	082H
TCON_TF1	BIT	088H.7
SCON1_RI	BIT	0C8H.0
SBUF0	DATA	099H
PCON0	DATA	087H
IPH	DATA	0F2H
ADC0GTL	DATA	0C3H
TMR4CN0_TF4H	BIT	098H.7
TMR4CN0_T4SPLIT	BIT	098H.3
TMR2CN0_TF2L	BIT	0C8H.6
SCON0_TI	BIT	098H.1
SBUF1	DATA	092H
PCON1	DATA	0CDH
ADC0LTH	DATA	0C6H
TCON_IT0	BIT	088H.0
SCON1_TI	BIT	0C8H.1
RSTSRC	DATA	0EFH
P0MAT	DATA	0FDH
CRC0DAT	DATA	0CBH
TMR5CN0_TF5H	BIT	0C0H.7
TMR5CN0_T5SPLIT	BIT	0C0H.3
TCON_IT1	BIT	088H.2
SFRSTACK	DATA	0D7H
SCON0	DATA	098H
PRTDRV	DATA	0F6H
P1MAT	DATA	0EDH
ADC0CN0_ADWINT	BIT	0E8H.3
SMOD1	DATA	093H
SCON1	DATA	0C8H
P2MAT	DATA	0FBH
TMR4CN0_TF4L	BIT	098H.6
ADC0CN0_ADBUSY	BIT	0E8H.4
SMB0ADM	DATA	0D6H
ADC0LTL	DATA	0C5H
SPI0CN0_MODF	BIT	0F8H.5
IP_PSPI0	BIT	0B8H.6
ADC0CN0_ADGN0	BIT	0E8H.1
PCA0CLR	DATA	09CH
TMR5CN0_TF5L	BIT	0C0H.6
ADC0CN0_ADGN1	BIT	0E8H.2
TMR2CN0	DATA	0C8H
TMR3CN0	DATA	091H
TMR2CN1	DATA	0FDH
TMR4CN0	DATA	098H
TMR3CN1	DATA	0FEH
TMR5CN0	DATA	0C0H
TMR4CN1	DATA	0FFH
SMB0ADR	DATA	0D7H
TCON_TR0	BIT	088H.4
TMR5CN1	DATA	0F1H
TMR2CN0_TF2CEN	BIT	0C8H.4
TCON_TR1	BIT	088H.6
SMB0DAT	DATA	0C2H
TMR2H	DATA	0CFH
SPI0CFG	DATA	0A1H
TMR3H	DATA	095H
HFOCN	DATA	0EFH
CRC0CNT	DATA	0D3H
TMR4H	DATA	0A5H
TMR4CN0_TF4CEN	BIT	098H.4
TMR5H	DATA	0D5H
SMB0FCT	DATA	0EFH
PCA0POL	DATA	096H
TMR2L	DATA	0CEH
TMR5CN0_TF5CEN	BIT	0C0H.4
SPI0CN0_SPIF	BIT	0F8H.7
TMR3L	DATA	094H
IE_EA	BIT	0A8H.7
TMR4L	DATA	0A4H
TMR5L	DATA	0D4H
TMR2CN0_TF2LEN	BIT	0C8H.5
SPI0CN0_WCOL	BIT	0F8H.6
SPI0CN0_NSSMD0	BIT	0F8H.2
PSW_CY	BIT	0D0H.7
UART1FCN0	DATA	09DH
SPI0PCF	DATA	0DFH
SPI0DAT	DATA	0A3H
I2C0FCN0	DATA	0ADH
SPI0CN0_NSSMD1	BIT	0F8H.3
ADC0	DATA	0BDH
UART1FCN1	DATA	0D8H
I2C0FCN1	DATA	0ABH
CLIF0_C0FIF	BIT	0E8H.0
TMR4CN0_TF4LEN	BIT	098H.5
CLIF0_C1FIF	BIT	0E8H.2
PSW	DATA	0D0H
PCA0PWM	DATA	0F7H
CLIF0_C2FIF	BIT	0E8H.4
SPI0FCT	DATA	0F7H
REVID	DATA	0B6H
TMR5CN0_TF5LEN	BIT	0C0H.5
CLIF0_C3FIF	BIT	0E8H.6
FLKEY	DATA	0B7H
?PR?_vTaskSchedule?ASMPORT               SEGMENT CODE
?DT?_vTaskSchedule?ASMPORT               SEGMENT DATA OVERLAYABLE
?PR?TIMER2_ISR?ASMPORT                   SEGMENT CODE
?XD?_vTaskSchedule?ASMPORT               SEGMENT XDATA OVERLAYABLE
?XD?TIMER2_ISR?ASMPORT                   SEGMENT XDATA OVERLAYABLE
	EXTRN	CODE (vTasksTick)
	EXTRN	XDATA (ctx)
	EXTRN	CODE (xSwitchContext)
	EXTRN	CODE (?C?PLDOPTR)
	EXTRN	CODE (?C?CSTOPTR)
	EXTRN	CODE (?C?COPY)
	EXTRN	CODE (?C?ISTOPTR)
	EXTRN	CODE (?C?CLDOPTR)
	PUBLIC	TIMER2_ISR
	PUBLIC	_vTaskSchedule

	RSEG  ?DT?_vTaskSchedule?ASMPORT
?_vTaskSchedule?BYTE:
      ticks?040:   DS   2

	RSEG  ?XD?_vTaskSchedule?ASMPORT
       task?041:   DS   3

	RSEG  ?XD?TIMER2_ISR?ASMPORT
       task?145:   DS   3
; #pragma SRC
; #include <SI_EFM8BB3_Register_Enums.h>
; #include <stdio.h>
; #include <stdlib.h>
; #include <string.h>
; #include <intrins.h>
; #include "sched.h"
;
; #define LED2R	0x08
;
; extern volatile struct sched_ctx * xdata ctx;
;
; //extern struct sched_task * xSwitchContext(struct sched_task * task) reentrant;
; extern struct sched_task * xSwitchContext(void);
; extern void vTasksTick(void);
;
; void vTaskSchedule(unsigned int ticks)

	RSEG  ?PR?_vTaskSchedule?ASMPORT
_vTaskSchedule:
	USING	0
;
; 	IE_EA = false;
			; SOURCE LINE # 25
	CLR  	IE_EA

	PUSH 	ACC
	PUSH 	B
	PUSH 	DPH
	PUSH 	DPL
	PUSH 	PSW
	MOV  	PSW,#00H
	PUSH 	AR0
	PUSH 	AR1
	PUSH 	AR2
	PUSH 	AR3
	PUSH 	AR4
	PUSH 	AR5
	PUSH 	AR6
	PUSH 	AR7


			; SOURCE LINE # 17
	MOV  	ticks?040,R6
	MOV  	ticks?040+01H,R7
; {
			; SOURCE LINE # 18
; 	struct sched_task * xdata task = ctx->head;
			; SOURCE LINE # 19
	MOV  	DPTR,#ctx
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	MOV  	DPTR,#03H
	LCALL	?C?PLDOPTR
	MOV  	DPTR,#task?041
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
;
; 	uint8_t idata * dptr;
; 	uint8_t xdata * xptr;
; 	uint8_t j;
;
; 	task->sp = SP;
			; SOURCE LINE # 27
	MOV  	DPTR,#task?041
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	MOV  	DPTR,#06H
	MOV  	A,SP
	LCALL	?C?CSTOPTR
;
; 	P2 ^= LED2R;  // Oszi: Gelb
			; SOURCE LINE # 29
	XRL  	P2,#08H
; 	memcpy(task->stack + REGS_SIZE, (uint8_t idata *) REGS_SIZE, STACK_SIZE - REGS_SIZE);
			; SOURCE LINE # 30
	MOV  	DPTR,#task?041
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	MOV  	DPTR,#07H
	LCALL	?C?PLDOPTR
	MOV  	A,R1
	ADD  	A,#08H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R0,AR1
	MOV  	R4,A
	MOV  	R5,AR3
	MOV  	R3,#00H
	MOV  	R2,#00H
	MOV  	R1,#08H
	MOV  	R6,#00H
	MOV  	R7,#0F8H
	LCALL	?C?COPY
; 	P2 ^= LED2R;  // Oszi: Gelb
			; SOURCE LINE # 31
	XRL  	P2,#08H
;
; 	task->delay = ticks;
			; SOURCE LINE # 33
	MOV  	DPTR,#task?041
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	MOV  	DPTR,#0DH
	MOV  	A,ticks?040
	MOV  	B,ticks?040+01H
	LCALL	?C?ISTOPTR
;
; 	task = xSwitchContext();
			; SOURCE LINE # 35
	LCALL	xSwitchContext
	MOV  	DPTR,#task?041
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
;
; 	//
; 	// memcpy takes about 100us and this loop about 250us, but we cannot use memcpy here
; 	// because it invokes a LCALL before we manipulate the stack, so on return we end up in nirvana
; 	//
;
; 	P2 ^= LED2R;  // Oszi: Gelb
			; SOURCE LINE # 42
	XRL  	P2,#08H
; 	xptr = task->stack + REGS_SIZE;
			; SOURCE LINE # 43
	MOV  	DPTR,#task?041
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	MOV  	DPTR,#07H
	LCALL	?C?PLDOPTR
	MOV  	A,R1
	ADD  	A,#08H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R6,A
	MOV  	R7,AR1
;---- Variable 'xptr?043' assigned to Register 'R6/R7' ----
; 	dptr = REGS_SIZE;
			; SOURCE LINE # 44
;---- Variable 'dptr?042' assigned to Register 'R5' ----
	MOV  	R5,#08H
; 	for ((uint8_t) j = STACK_SIZE - REGS_SIZE; j; j--)
			; SOURCE LINE # 45
;---- Variable 'j?044' assigned to Register 'R4' ----
	MOV  	R4,#0F8H
?C0001:
; 		*(dptr++) = *(xptr++);
			; SOURCE LINE # 46
	INC  	R7
	MOV  	A,R7
	MOV  	R2,AR6
	JNZ  	?C0009
	INC  	R6
?C0009:
	DEC  	A
	MOV  	DPL,A
	MOV  	DPH,R2
	MOVX 	A,@DPTR
	MOV  	R2,AR5
	INC  	R5
	MOV  	R0,AR2
	MOV  	@R0,A
	DJNZ 	R4,?C0001
?C0002:
; 	P2 ^= LED2R;  // Oszi: Gelb
			; SOURCE LINE # 47
	XRL  	P2,#08H
;
; 	SP = task->sp;
			; SOURCE LINE # 49
	MOV  	DPTR,#task?041
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	MOV  	DPTR,#06H
	LCALL	?C?CLDOPTR
	MOV  	SP,A

	POP  	AR7
	POP  	AR6
	POP  	AR5
	POP  	AR4
	POP  	AR3
	POP  	AR2
	POP  	AR1
	POP  	AR0
	POP  	PSW
	POP  	DPL
	POP  	DPH
	POP  	B
	POP  	ACC

;
; 	IE_EA = true;
			; SOURCE LINE # 51
	SETB 	IE_EA
;
; 	return;
; }
			; SOURCE LINE # 54
	RET
; END OF _vTaskSchedule

CSEG	AT	0002BH
	LJMP	TIMER2_ISR

;
; /*
;  * SI_INTERRUPT (TIMER2_ISR, TIMER2_IRQn)
;  * void TIMER2_ISR (void) interrupt TIMER2_IRQn
;  * https://developer.arm.com/documentation/ka002595/latest
;  * using this C51 hopefully saves the registers onto the stack by itsself before and after the ISR
;  * The ISR takes about 375us @ 24,5MHz to copy the 256 byte stack back and forth
;  */
;
; SI_INTERRUPT (TIMER2_ISR, TIMER2_IRQn)

	RSEG  ?PR?TIMER2_ISR?ASMPORT
	USING	0
TIMER2_ISR:
	PUSH 	ACC
	PUSH 	B
	PUSH 	DPH
	PUSH 	DPL
	PUSH 	PSW
	MOV  	PSW,#00H
	PUSH 	AR0
	PUSH 	AR1
	PUSH 	AR2
	PUSH 	AR3
	PUSH 	AR4
	PUSH 	AR5
	PUSH 	AR6
	PUSH 	AR7
	USING	0
			; SOURCE LINE # 64
; {
; 	struct sched_task * xdata task = ctx->head;
			; SOURCE LINE # 66
	MOV  	DPTR,#ctx
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	MOV  	DPTR,#03H
	LCALL	?C?PLDOPTR
	MOV  	DPTR,#task?145
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
;
; 	uint8_t idata * dptr;
; 	uint8_t xdata * xptr;
; 	uint8_t j;
;
; 	TMR2CN0_TF2H = 0;                            // Timer Interrupt quittieren
			; SOURCE LINE # 72
	CLR  	TMR2CN0_TF2H
;
; //	P2 ^= LED2R;  // Oszi: Gelb
;
; //	WDTCN = 0xA5;
;
; //	TMR2CN0_TR2 = false;						 // stop the Timer
;
; //	printf("vTaskSchedule\r\n");
;
; 	task->sp = SP;
			; SOURCE LINE # 82
	MOV  	DPTR,#task?145
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	MOV  	DPTR,#06H
	MOV  	A,SP
	LCALL	?C?CSTOPTR
;
; 	P2 ^= LED2R;  // Oszi: Gelb
			; SOURCE LINE # 84
	XRL  	P2,#08H
; 	memcpy(task->stack + REGS_SIZE, (uint8_t idata *) REGS_SIZE, STACK_SIZE - REGS_SIZE);
			; SOURCE LINE # 85
	MOV  	DPTR,#task?145
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	MOV  	DPTR,#07H
	LCALL	?C?PLDOPTR
	MOV  	A,R1
	ADD  	A,#08H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R0,AR1
	MOV  	R4,A
	MOV  	R5,AR3
	MOV  	R3,#00H
	MOV  	R2,#00H
	MOV  	R1,#08H
	MOV  	R6,#00H
	MOV  	R7,#0F8H
	LCALL	?C?COPY
; 	P2 ^= LED2R;  // Oszi: Gelb
			; SOURCE LINE # 86
	XRL  	P2,#08H
;
; 	vTasksTick();
			; SOURCE LINE # 88
	LCALL	vTasksTick
;
; //	task = (ctx->head = task->next == NULL ? ctx->root : task->next);
;
; 	task = xSwitchContext();
			; SOURCE LINE # 92
	LCALL	xSwitchContext
	MOV  	DPTR,#task?145
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
;
; 	//
; 	// memcpy takes about 100us and this loop about 250us, but we cannot use memcpy here
; 	// because it invokes a LCALL before we manipulate the stack, so on return we end up in nirvana
; 	//
;
; 	P2 ^= LED2R;  // Oszi: Gelb
			; SOURCE LINE # 99
	XRL  	P2,#08H
; 	xptr = task->stack + REGS_SIZE;
			; SOURCE LINE # 100
	MOV  	DPTR,#task?145
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	MOV  	DPTR,#07H
	LCALL	?C?PLDOPTR
	MOV  	A,R1
	ADD  	A,#08H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R6,A
	MOV  	R7,AR1
;---- Variable 'xptr?147' assigned to Register 'R6/R7' ----
; 	dptr = REGS_SIZE;
			; SOURCE LINE # 101
;---- Variable 'dptr?146' assigned to Register 'R5' ----
	MOV  	R5,#08H
; 	for ((uint8_t) j = STACK_SIZE - REGS_SIZE; j; j--)
			; SOURCE LINE # 102
;---- Variable 'j?148' assigned to Register 'R4' ----
	MOV  	R4,#0F8H
?C0005:
; 		*(dptr++) = *(xptr++);
			; SOURCE LINE # 103
	INC  	R7
	MOV  	A,R7
	MOV  	R2,AR6
	JNZ  	?C0010
	INC  	R6
?C0010:
	DEC  	A
	MOV  	DPL,A
	MOV  	DPH,R2
	MOVX 	A,@DPTR
	MOV  	R2,AR5
	INC  	R5
	MOV  	R0,AR2
	MOV  	@R0,A
	DJNZ 	R4,?C0005
?C0006:
; 	P2 ^= LED2R;  // Oszi: Gelb
			; SOURCE LINE # 104
	XRL  	P2,#08H
;
; 	SP = task->sp;
			; SOURCE LINE # 106
	MOV  	DPTR,#task?145
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	MOV  	DPTR,#06H
	LCALL	?C?CLDOPTR
	MOV  	SP,A
;
; //	TMR2CN0_TR2 = true;						 // start the Timer again
;
; //	P2 ^= LED2R;  // Oszi: Gelb
; }
			; SOURCE LINE # 111
	POP  	AR7
	POP  	AR6
	POP  	AR5
	POP  	AR4
	POP  	AR3
	POP  	AR2
	POP  	AR1
	POP  	AR0
	POP  	PSW
	POP  	DPL
	POP  	DPH
	POP  	B
	POP  	ACC
	RETI
; END OF TIMER2_ISR

	END
